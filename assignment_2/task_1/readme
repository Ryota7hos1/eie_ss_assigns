# UDP Chat System  
**Ryota Hosokawa (CID: 02591705)**  
**Seiji Ethan Cann (CID: 02592695)**  

---

## 1. Project Overview
This project implements a multithreaded **UDP chat system** in C with a **terminal-based client**.  
It consists of:

- A **central UDP server** that manages clients, message routing, and history  
- Multiple **ncurses-based clients**, each using a **three-thread architecture**  

The system demonstrates concurrency, synchronization, and UDP communication by enabling users to join, exchange messages, and interact in real time.  
Both server and client employ **multiple threads and mutexes** to ensure safe parallel access to shared data.

---

## 2. Short Description

### **Client**
- Ncurses-based UI with separate input/output windows  
- **Three threads**:
  - `initial_thread` – performs initial `conn$NAME` handshake  
  - `sender_thread` – reads user input and sends commands  
  - `listener_thread` – receives messages from server  
- Supports connection, disconnection (including forced), reconnection, message sending  
- Thread-safe UI using global ncurses mutex  

### **Server**
- UDP server bound to port **12000**
- Maintains:
  - Linked list of **connected users**
  - Linked list of **disconnected users**
  - `BlockNode` linked list for **mute relationships**
- Each user node contains:
  - Name  
  - `sockaddr_in`  
  - Last active timestamp  
  - Connected boolean  
  - `muted_by` BlockNode list  
  - Circular buffer (private history)
- Server node stores **global history buffer**
- **Three-thread architecture**:
  - `listener_thread` – receives packets, spawns worker threads  
  - `worker_thread` – processes commands & updates shared state  
  - `cleanup_thread` – checks inactivity and disconnects idle clients  
- Handles commands: `conn`, `say`, `sayto`, `disconn`, `mute`, `unmute`, `rename`, `ret-ping`, `kick`  

---

## 3. Features Implemented

### **Client Features**

| Feature               | Implemented | Notes |
|----------------------|-------------|-------|
| UDP Port (Random)    | Full        | `./client` → random port, `./client admin` → port 6666 |
| Sender thread        | Full        | Sends requests based on connection state |
| Listener thread      | Full        | Receives packets; safe from injection; handles forced disconnect |
| Initial thread       | Full        | Blocks other threads until a valid `conn$` |
| Supporting requests  | Full        | Basic validation before sending |
| User Interface        | Full        | Ncurses windows, thread-safe, full history visible with large terminal |

### **Server Features**

| Feature               | Implemented | Notes |
|----------------------|-------------|-------|
| UDP Port (12000)     | Full        | Fixed port |
| Listener Threads     | Full        | Spawns worker thread per packet |
| Responding Thread    | Full        | Single handler for all instructions |
| Linked List Data     | Full        | Lists for connected, disconnected, and mute nodes |
| Circular Buffer      | Full        | Global + per-user private history |
| conn$                | Full        | Connects or reconnects; sends histories |
| say$                 | Full        | Broadcast except to those who muted sender |
| sayto$               | Full        | Private messaging; saved in both user buffers |
| disconn$             | Full        | Moves user to disconnected list |
| mute$                | Full        | Reverse-logic mute tracking via BlockNode |
| unmute$              | Full        | Removes BlockNode entry |
| rename$              | Full        | Enforces name uniqueness (including disconnected users) |
| kick$                | Full        | Admin-only force disconnect |

### **Synchronization**
- **Reader–writer lock** for linked lists  
- Circular buffer locking inside buffer functions  

### **Extensions**
- **Extension 1** – Global circular buffer for history (Full)  
- **Extension 2** – Cleanup thread removing inactive clients (Full)  
- **Reconnection state preservation** – Partial (private + global history maintained)  
- **Other enhancements** – Partial (extra checks, structure improvements)  

---

## 4. How to Compile & Run

## **Server**
```bash
gcc chat_server.c -o server -lpthread
./server
# or
./server &
### **Client**
```bash
gcc chat_client.c -o client -lncurses -lpthread
./client         # uses a random available port
./client admin   # uses port 6666 (admin port)

### **Example Session**
Client 1           Client 2                Client Admin
-------------------------------------------------------------
conn$ c1           conn$ c2                conn$ admin111
say$ hi
sayto$ c2 hello
mute$ c2           sayto$ c1 hi c1
unmute$ c2         say$ can you hear me c1
rename$ c3         sayto$ c3 you changed your name
                   disconn$
                                          kick$ c3
conn$



---

## 5. Architecture & Design

### Data Structures

**Linked Lists**
- Nodes:
  - name  
  - sockaddr_in  
  - BlockNode  
  - last_active  
  - connected  
  - circular buffer  
  - circular buffer lock  
  - next  

**BlockNodes (Reverse mute relationship, i.e., "muted_by" list)**
- Node (the user who muted)
- next

---

### Thread Architecture

**Server Threads**
- `listener_thread` – spawns worker threads  
- `worker_thread` (many) – handles all incoming packets and executes commands  
- `cleanup_thread` – removes inactive (idle) clients  

**Client Threads**
- `initial_thread`  
- `sender_thread`  
- `listener_thread`  

---

## 6. Explanation of Design Choices

### State Preservation
- Users are never fully freed until server termination.  
- This allows seamless reconnection with full private + global chat history.

### Memory Management
- No explicit memory freeing.  
- Server and clients rely on OS to reclaim memory after process termination.

### Server Node Global Buffer
- The server node stores the global chat history.  
- It has no private messages, making it an ideal place for global state.

### Single Worker Thread Approach
- Instead of separate handlers for each instruction, one unified worker thread handles all commands.  
- Simplifies code and avoids cross-thread conflicts.

### Robust Initial Connection
- A dedicated initial thread on the client ensures no actions occur until server responds `ok`.  
- Prevents race conditions with listener thread.

### Unified Disconnection Logic
- `disconn$`, timeout inactivity, and admin `kick$` all behave identically.  
- This ensures consistent reconnection behavior.

---

## 7. Considered Cases

- **Multi-word names** disallowed (checked on both client & server for `conn$` and `rename$`).  
- **Duplicate names** disallowed (checked against connected + disconnected clients).  
- **Muting same user multiple times** prevented with BlockNode checks.  
- **Muting/unmuting disconnected users** not allowed.  
- **UDP buffer unreliability**:  
  - Listener thread may receive duplicate packets (e.g., requiring `conn$` twice).  
  - Added `args->reconnecting` boolean to prevent race conditions between sender and listener threads when updating `args->connected`.

- **Multi-level disconnection checks**:  
  - Both client and server ensure clients receive no messages while disconnected.

- **Safe initial connection**:  
  - Initial logic separated from sender thread to prevent actions before server approval.

- **sayto$ targeting server**:  
  - Not allowed; server returns an error.

- **Global history includes muted users' messages**:  
  - Global circular buffer stores all broadcast (`say$`) messages.  
  - Returning clients may see messages from users they muted earlier.  
  - Considered acceptable and low priority.

---
